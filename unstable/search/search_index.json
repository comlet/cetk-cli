{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>comlet's Embedded TestKit is a platform independent (embedded) test automation solution and Robotic Process Automation (RPA) environment which consists of the following parts:</p> <p></p> <ul> <li>Control Environment</li> <li>Robot Framework as Test Automation Framework</li> <li>Python</li> <li>Tidy as test source beautifier</li> <li>KeePass Library for managing secrets</li> <li>Robocop for static (test) source code analysis</li> <li>Optional (depending on project needs)<ul> <li>Thirdparty/external technology/device driver libraries</li> <li>comlet Embedded Libraries</li> </ul> </li> <li>comlet Embedded Simulation Devices</li> <li>Frontend to define test cases according to ISO29119-5 (provided by Robot Framework)</li> <li>\"cetk-cli\"</li> </ul> <p>Main emphasis of test automation with Embedded TestKit (but not limited to) is black-box and end-to-end testing.</p> <p>The architecture of Embedded TestKit inherits from the generic Test Automation Architecture (gTAA) as described by ISTQB(tm) in their Advanced Level Syllabus for Test Automation Engineer.</p> <p>Key features that can be realized with Embedded TestKit: * Keyword-Driven (ISO29119-5) * Test-Driven * Continuous Testing (by integration with a CI/CD server - e.g, by Jenkins) * Functional and non-functional testing (ISO25010) * Behavior- and Data-Driven</p> <p>Key properties of Embedded TestKit: * Flexible Environment/Architecture * Augmented Requirements * Complexity Reduction</p>"},{"location":"#control-environment","title":"Control Environment","text":"<p>Embedded TestKit's control environment is a logical entity that either runs encapsulated and self-contained inside a linux Docker container as part of a Docker compose configuration, or it runs natively on the host platform and assumes all the tools needed are available locally (e.g. installed globally, as Python virtualenv or Conda environment).</p> <p>In general, all a host needs to execute test cases with Embedded TestKit is:</p> <ul> <li>Linux, Windows or macOS host platform</li> <li>tested under Ubuntu 20.04 LTS and 22.04 LTS, Debian 11.3.0, Windows 10 and macOS &gt; 12 (Apple silicon)</li> <li>Python Version 3.10 or later</li> <li>For the Docker configuration</li> <li>Docker engine (e.g. provided by native installation, Docker Desktop or Ranger Desktop)<ul> <li>tested with version 20.10.06, 20.10.12, 20.10.17, 25.0.3 and 27.2.0</li> </ul> </li> <li>Docker compose v2 cli-plugin (not the stand-alone docker-compose tool)<ul> <li>tested with version 2.2.3, 2.6.0, 2.24.5 and 2.29.2</li> </ul> </li> <li>For the native configuration</li> <li>Locally installed tools (e.g. with the help of a Python virtualenv or Conda environment)</li> </ul>"},{"location":"#environment-variables","title":"Environment variables","text":"<p>There are following environment variables available to be utilized inside Embedded TestKit's control environment: * $TMP which holds the path to a tmp folder (only available for Docker configuration) * $CETK_SOURCE_HOME which holds the path to the (mandatory) source folder * $CETK_SOURCE_HOME_CONTAINER which holds the path to the (mandatory) source folder specific to the linux Docker container (only available for Docker configuration) * $PYTHONPATH with optional path(s) to Python or Robot Framework libraries</p>"},{"location":"#robot-framework-rf","title":"Robot Framework (RF)","text":"<p>According to gTAA, Robot Framework covers Test Definition as well as Test Execution Layer. Definition of test cases can be done keyword -, behavior - or data driven. There are many external resources ready to be used with RF that cover Test Adapter Layer. For further documentation of RF, feel free to visit RF's User Guide.</p>"},{"location":"#python","title":"Python","text":"<p>Python is the core programming language of Embedded TestKit and together with RF covers Test Execution Layer. It also can be utilized to adapt technologies for test automation on the Test Adaption Layer. Currently, the integrated version and therefor the maximum API to program against is 3.10.x. As a style guide, please follow PEP 8</p>"},{"location":"#comlet-embedded-libraries-cel","title":"comlet Embedded Libraries (cEL)","text":"<p>comlet Embedded Libraries are pure software libraries developed by comlet to adapt to or simulate embedded technology and protocols needed for test automation, resp. RPA. Those libraries extend the test adaption layer according to gTAA.</p>"},{"location":"#comlet-embedded-simulation-devices-cesd","title":"comlet Embedded Simulation Devices (cESD)","text":"<p>In contrast to embedded libraries, comlet Embedded Simulation Devices also include custom hardware for simulating embedded technology and protocols needed for test automation, resp. RPA. Communication between the control environment (test cases) and cESD is done via a unified REST API infrastructure based on Open API.</p>"},{"location":"#how-to-use","title":"How to use","text":"<p>\"cetk-cli\" is the command-line interface for comlet's Embedded TestKit.</p> <p>Following parts of the documentation show how to use Embedded TestKit without any given project context (aka \"vanilla\") from command line. Most of the time, it's going to be embedded in a real-world project - for example with comlet's own build process.</p> <p>All given examples are for a host running Linux as operating system and the control environment configured for docker (hence a Docker engine must be available). Nevertheless, the same interface can be used on other platforms, just make sure the correct Python is part of the host's PATH. The interface has a -h (as in help) option which gives further details on usage.</p>"},{"location":"#installing-cetk-cli","title":"Installing cetk-cli","text":"<p>The command line interface can be installed as Python wheel by its name \"cetk-cli-bin\" (e.g. by pip) which will install a platform specific binary version incl. a default environment definition file, Docker compose configuration and tidy, robocop configurations.</p>"},{"location":"#configure-control-environment","title":"Configure Control Environment","text":"<p>Configuration is done via the environment variable definition file or by defining the following environment variables manually.</p> <p>Note: manually defined environment variables take precedence over those defined in the Environment Variable Definition File.</p> <ul> <li>CETK_ENVIRONMENT: [docker|native] - default: native</li> <li>CETK_CORE_IMAGE: name of the core image to be used when configured as docker environment</li> </ul>"},{"location":"#environment-variable-definition-file","title":"Environment Variable Definition File","text":"<ul> <li>with --env-file, a path can be specified where an optional/project specific .env file is loaded from, e.g. from systemtest/.env</li> <li>default behavior if no --env-file option is given: the internal default .env file from the cetk-cli is loaded </li> <li>In general, using a .env file is optional unless the control environment is run inside a Docker container (see Configure Control Environment)</li> </ul>"},{"location":"#running-executables-in-general","title":"Running EXECUTABLEs in general","text":"<p>To execute any allowed EXECUTABLE inside the control environment: <pre><code>cetk ARGUMENT(s) EXECUTABLE ARGUMENT(s)\n</code></pre></p> <p>For more information on usage and which EXECUTABLES are allowed to be run inside the control environment, see the help option of the interface: <pre><code>cetk --help\n</code></pre> This command will display all available options and commands, detailing each aspect of cetk-cli's functionality for quick reference. Every EXECUTABLE also provides a help by an --help option.</p> <p>Note: If used with docker configuration, the core image is downloaded from comlet's paketmanager for the first time and the user agnostic main (one-off) image is built automatically from it.</p> <p>Default (test) source home folder path that is utilized is the root project folder, e.g.:   * if the host path of cetk is /home/user/git/repo/   * -&gt; (test) sources path becomes /home/user/git/repo</p>"},{"location":"#special-path-handling-of-executables-arguments-for-docker-configuration","title":"Special path handling of EXECUTABLE's ARGUMENT(s) for Docker configuration","text":"<p>If docker configuration is used, keep in mind that the target platform may be different from the host platform. Therefore, all paths given as ARGUMENT for an EXECUTABLE must comply to the target platform.</p> <p>Example: the host platform is Windows and the control environment is configured for Docker (hence the target platform is linux).</p> <pre><code>path\\to\\cetk robot path/to/test_suite.robot\n</code></pre>"},{"location":"#using-dedicated-source-home-folder-as-base-for-executables","title":"Using dedicated source home folder as base for EXECUTABLEs","text":"<p>To achieve this, use following options with the cetk module (if default path is not sufficient):</p> <pre><code>cetk -s /path/to/sources/on/host EXECUTABLE ARGUMENT(s)\n</code></pre> <ul> <li>-s is the absolute path to the source folder on the host machine (e.g. this repo's folder) that shall be utilized</li> <li>working directory for test execution becomes /path/to/sources/on/host</li> </ul>"},{"location":"#using-optional-binaryoutput-folder","title":"Using optional binary/output folder","text":"<p>It's in general a good idea to separate source and binary/output folder to comply with out-of-source build guidelines. To achieve this with Embedded TestKit, there's an additional option that can be utilized and that works the same way as -s option:</p> <ul> <li>-o is the absolute path to the binary/output folder on the host machine that shall be utilized inside the control environment, if it is not given source home will be used</li> </ul>"},{"location":"#adding-additional-contextdocker-container-to-be-executed","title":"Adding additional context/Docker container to be executed","text":"<p>If a (project) specific context for test automation is needed (e.g., additional Docker images need to be started and executed), additional Docker compose files can be provided with the -f option that are merged with the default compose.yaml. Additionally, already defined properties can be overwritten with this approach. To learn more about the compose specification, read on here.</p>"},{"location":"#test-execution-robot","title":"Test execution (robot)","text":"<p>Test execution is started with the dedicated robot EXECUTABLE.</p> <pre><code>cetk robot /path/to/test_suite.robot\n</code></pre>"},{"location":"#features-enabled-by-default","title":"Features enabled by default","text":"<p>The following features are enabled by default:</p> <ul> <li><code>--skiponfailure not_ready</code></li> <li>test cases with this tag are executed but their result is ignored (aka skipped) for the overall result</li> <li><code>--randomize tests</code></li> <li>randomize execution of test cases inside test suites (seed to reproduce can be observed in log)</li> <li><code>--removekeywords tag:no_logging</code></li> <li>keywords with this tag do not log anything (e.g., because this would log a password)</li> <li><code>--exclude dont_run</code></li> <li>test cases with this tag are not executed</li> <li><code>--xunit output_xunit.xml</code></li> <li>Additional report in xunit format to be integrated in CI server like gitlab or jenkins</li> </ul>"},{"location":"#test-documentation-testdoc","title":"Test documentation (testdoc)","text":"<p>Generation of test documentation is started with the dedicated testdoc EXECUTABLE.</p> <pre><code>cetk testdoc /path/to/test_suite.robot path/to/testdoc.html\n</code></pre>"},{"location":"#features-enabled-by-default_1","title":"Features enabled by default","text":"<p>The following features are enabled by default:</p> <ul> <li><code>--exclude dont_run</code></li> <li>test cases with this tag will not show up in test documentation</li> </ul> <p>For further documentation of RF's Testdoc, feel free to visit RF's User Guide for Testdoc chapter.</p>"},{"location":"#test-source-beautifier-tidy","title":"Test source beautifier (tidy)","text":"<p>Beautifying test sources, i.e. test suites (.robot) and resource files (.resource) is started with the dedicated tidy EXECUTABLE.</p> <pre><code>cetk tidy /path/to/test_suite.robot\n</code></pre> <p>A default configuration is part of the cetk-cli but if the default config is not sufficient:</p> <pre><code>cetk tidy --config /path/to/config.toml /path/to/test_suite.robot\n</code></pre>"},{"location":"#features-enabled-by-default_2","title":"Features enabled by default","text":"<p>The following features can be enabled by cli: * <code>--check</code>   * Robotidy can return exit code 1 if any file would be transformed</p> <p>For further documentation of Robotidy, feel free to visit Robotidy's website.</p>"},{"location":"#static-test-source-code-analysis-robocop","title":"Static (test) source code analysis (robocop)","text":"<p>Perform a static (test) source code analysis of test suites (.robot) and resource files (.resource) with the dedicated robocop EXECUTABLE.</p> <pre><code>cetk robocop /path/to/directory/or/file.robot\n</code></pre> <p>A default configuration is part of the cetk-cli but if the default config is not sufficient:</p> <pre><code>cetk robocop --config /path/to/config.toml /path/to/directory/or/file.robot\n</code></pre>"},{"location":"#features-enabled-by-default_3","title":"Features enabled by default","text":"<p>Robocop fails if an error or warning rule is broken. All errors and warnings must be fixed - infos are optional but recommended to be looked into as well. If a rule is disabled, this has to be done as an ultima ratio, only, and the rationale well explained during review.</p> <p>For further documentation of Robocop, feel free to visit Robocop's website.</p>"},{"location":"#library-documentation-libdoc","title":"Library documentation (libdoc)","text":"<p>Generation of (keyword) library html documentation is started with the dedicated libdoc EXECUTABLE. Documentation can be created for test libraries (*.py) or resource files (*.resource).</p> <pre><code>cetk libdoc /path/to/library.resource /path/to/library.html\n</code></pre> <p>To use the library documentation tool a certain syntax must be followed.</p> <p>Example syntax for sources:</p> <pre><code>\"\"\"Example library in Robot Framework format.\n\n- Formatting with *bold* and _italic_.\n- URLs like https://example.com are turned to links.\n- Custom links like [https://robotframework.org|Robot Framework] are supported.\n- Linking to `My Keyword` works.\n\"\"\"\n\ndef my_keyword():\n    \"\"\"Nothing more to see here.\"\"\"\n</code></pre> <p>For further documentation of RF's Libdoc, feel free to visit RF's User Guide for Libdoc chapter.</p>"},{"location":"#merging-several-reports-and-logs-rebot","title":"Merging several reports and logs (rebot)","text":"<p>Combining logs and reports (from their source .xml files) is started with the dedicated rebot* EXECUTABLE.</p> <p>This script runs the following tasks: * Passing all arguments to the execution of RF's Rebot</p> <p>Example:</p> <pre><code>cetk rebot --outputdir /path/to/combined_output --name some_overall_log_title /path/to/input\\*.xml_files\n</code></pre>"},{"location":"#features-enabled-by-default_4","title":"Features enabled by default","text":"<p>The following features are enabled by default which in general save all output artifacts as additional _combined variant:</p> <ul> <li><code>--output output_combined.xml</code></li> <li><code>--xunit output_xunit_combined.xml</code></li> <li><code>--report report_combined.html</code></li> <li><code>--log log_combined.html</code></li> </ul> <p>For further documentation of RF's Rebot feel free to visit RF's User Guide for post-processing output chapter.</p>"},{"location":"#saving-artefacts","title":"Saving artefacts","text":""},{"location":"#store-executable-results-in-output-home","title":"Store executable results in output home","text":"<p>If output home -o option is used, the result from the executables is stored in path/to/output_home/artefacts/[executable].</p> <p>If output home -o option is not used, the result from the executables is stored in path/to/source_home/artefacts/[executable].</p> <p>In the case the user add the specific executable output option in addition, this will be overriden and the standard folder will be used.</p> <p>For testdoc the standard artefact name is testdoc.html.</p> <p>For libdoc the standard artefact name is libdoc.html.</p>"}]}